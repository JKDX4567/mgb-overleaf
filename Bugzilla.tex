\chapter{Bugzilla}
\small{\textit{-- Matthew Smith, Bowen Jiang, Gleb Myshkin}}
\index{hosts} 
\index{Chapter!Bugzilla }
\label{Chapter Bugzilla}


\section{Sign Up For The Credit }
\begin{figure} [H]
\includegraphics[width=\textwidth]{digital ocean.png}
  \centering
  \caption{Digital Ocean 200 Credits}
  \vspace{-0.3cm}
\end{figure}


\section{How To Configure Bugzilla in Digital Ocean}

\begin{lstlisting}[style=linuxstyle, language=bash]
#ChatGPT & Gemini was used to get the following code (comments not included):

#The first thing that needed to be done was creating a new Droplet in Digital Ocean. By clicking Create, then selecting the closest database location (New York), and then naming the droplet and selecting a payment plan. After that, a password was created then the droplet was created with the name of bugzilla-droplet. After this, the console was opened through Digital Ocean and then code was used.

#The first thing that was done was creating new directories in the droplet.
#Create Docker directoy
mkdir Docker

#Then another directory was created inside of Docker
cd Docker
mkdir Bugzilla

#After that, new files were created and edited with the help of nano.
nano Dockerfile

#The Dockerfile has the following code in it with some comments created by Gemini AI:

# 1. Start from a minimal Debian operating system
FROM debian:bullseye-slim

# Set environment variables to prevent interactive prompts during installation
ENV DEBIAN_FRONTEND=noninteractive

# 2. Install dependencies, including build tools for the MariaDB driver
RUN apt-get update && apt-get install -y \
    apache2 \
    perl \
    build-essential \
    default-libmysqlclient-dev \
    libappconfig-perl \
    libdate-calc-perl \
    libtemplate-perl \
    libemail-mime-perl \
    libemail-sender-perl \
    libemail-address-perl \
    libcgi-pm-perl \
    libmath-random-isaac-perl \
    libdbd-mysql-perl \
    liblist-moreutils-perl \
    libjson-xs-perl \
    libdatetime-timezone-perl \
    libdbix-connector-perl \
    patchutils \
    libgd-gd2-perl \
    libchart-perl \
    libtemplate-plugin-gd-perl \
    libxml-twig-perl \
    git \
    && rm -rf /var/lib/apt/lists/*

# 3. Use Git to clone the latest stable 5.2 branch of Bugzilla
RUN git clone --branch 5.2 --single-branch https://github.com/bugzilla/bugzilla.git /var/www/html/bugzilla

# 4. Set WORKDIR and install required/optional Perl modules
WORKDIR /var/www/html/bugzilla
# Install the specific MariaDB driver
RUN ./install-module.pl DBD::MariaDB
# Install the other required modules
RUN ./install-module.pl Template && \
    ./install-module.pl Email::Sender && \
    ./install-module.pl Email::Address::XS

# 5. Set the correct permissions for the Bugzilla directory
RUN chown -R www-data:www-data /var/www/html/bugzilla && \
    chmod -R 775 /var/www/html/bugzilla

# 6. Copy our custom Apache config into the container and enable it
COPY bugzilla.conf /etc/apache2/sites-available/
RUN a2dissite 000-default.conf && \
    a2ensite bugzilla.conf && \
    a2enmod cgi headers expires cgid rewrite

# 7. Expose port 80 to the outside world
EXPOSE 80

# 8. Set the default command to start the web server
CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]

#Code to create docker-compose.yml file:
nano docker-compose.yml

#The following is the YAML file used named docker-compose.yml (real passwords not included):
# Define a shared variable for the password
x-environment:
  &db-password
  MYSQL_PASSWORD: "a_strong_user_password" #<-- DEFINE PASSWORD ONCE HERE

version: "3.7"

services:
  db:
    image: mariadb:10.6
    container_name: bugzilla-db
    command: --character-set-server=utf8 --collation-server=utf8_general_ci
    environment:
      <<: *db-password # Use the shared password
      MYSQL_ROOT_PASSWORD: "a_strong_root_password"
      #Names set to bugs
      MYSQL_DATABASE: "bugs"
      MYSQL_USER: "bugs"
    volumes:
      - bugzilla-db-data:/var/lib/mysql

  bugzilla:
    build: .
    container_name: bugzilla-app
    depends_on:
      - db
    ports:
      - "8080:80"
    volumes:
      - ./localconfig:/var/www/html/bugzilla/localconfig
      - bugzilla-app-data:/var/www/html/bugzilla/data
    environment:
      BUGZILLA_DB_HOST: "db"
      #Names set to bugs
      BUGZILLA_DB_NAME: "bugs"
      BUGZILLA_DB_USER: "bugs"
      BUGZILLA_DB_PASS: "a_strong_user_password" # <-- AND MAKE SURE IT MATCHES HERE
      BUGZILLA_URL: "http://your_droplet_ip:8080/" # Replace with your IP

volumes:
  bugzilla-db-data:
  bugzilla-app-data:

#Code used to create the Apache web server configuration file:
nano bugzilla.conf

#The following is the code inside of bugzilla.conf:
<VirtualHost *:80>
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html/bugzilla

    <Directory /var/www/html/bugzilla>
        AddHandler cgi-script .cgi
        AllowOverride All
        Options +ExecCGI
        Require all granted
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>

#After all of the needed files were created, the following code was ran to build and run it:
docker-compose up --build -d

#This line of code gave quite a bit of issues as when it was building, there were a lot of packages missing which were needed to be added in the Dockerfile.

#One other problem was the missing docker-compose tool, so the following code was needed to install it:
sudo apt install docker-compose

#After that, we tried to build and run it again, but found out that the container that we were using didn't have a lot of memory and kept crashing after trying to build all of the packages. To fix this, a swap file was created  to act as temporary RAM. The following code was entered, line by line, hitting enter after each line of code (ENTER indicated a press of the return button).

sudo fallocate -l 2G /swapfile ENTER
sudo chmod 600 /swapfile ENTER
sudo mkswap /swapfile ENTER
sudo swapon /swapfile ENTER
echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab ENTER

#This created a file that was 2 GB that was used as temp RAM, and it would always be used after a container reset due to the echo line of code.

#After fixing the memory issue, we continued. The next thing we did was opening a command prompt inside of the Bugzilla container:
docker-compose exec bugzilla bash

#After that, we needed to run the following code to setup the admin email, name, and password to finally get the website up and running:
./checksetup.pl

#There were quite a bit of errors after running this, one of which was a file and directory name localconfig that messed up some things. In order to fix this, we edited the YAML file a bit and made sure that the localconfig volume wasn't created during build phase. The file codes pasted above are all up to date with all the new changes and additions. 

#We created a localconfig file in the Bugzilla directory
touch localcondig

#After those changes, and after building/running the container, we went into localconfig to change some things that the Bugzilla image required.

#$db_driver and $webservergroup were changed in localconfig
#From $db_driver = 'mysql' to $db_driver = 'mariadb'
#From $webservergroup = 'apache' to $webservergroup = 'www-data'

#If some errors occured, the following was used to turn off the container:
docker-compose down

#Or the following if we needed a reset and to delete the volumes

docker-compose down --volumes

#After we made our changes, we'd get it back up with :
docker-compose up --build -d

#Or the following if we didn't need to build it again:
docker-compose up -d

#This was pretty much it. After all of the changes and the resolved errors, the following was the last line of code used in the exec root directory:
./checksetup.pl

#After this, we had a pop-up that told us to add an Admin Email, Name, and Password. There was no code, just direct inputs in the terminal. After all of this, we managed to get the Bugzilla website running through our Digital Ocean with a working admin account.

  
\end{lstlisting}